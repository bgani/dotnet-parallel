using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Net;
using System.Threading;

namespace DotNetParallel.AsyncAwaitDemo
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public async Task<int> CalculateValueAsync()
        {
            await Task.Delay(5000);
            return 123;
        }

        public MainWindow()
        {
            InitializeComponent();
        }

        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            int value = await CalculateValueAsync();
            // release UI thread

            LblResult.Content = value.ToString();

            await Task.Delay(5000);

            using(var wc = new WebClient())
            {
                string data = await wc.DownloadStringTaskAsync("https://google.com/robots.txt");

                LblResult.Content = data.Split('\n')[0].Trim();
            }
        }

        // Task.Run is a shortcut for:
        // 1. Task.Factory.StartNew();
        // 2. Unwrap() the result
        // by making labmda as async compiler will map this delegate to be a Func<Task<int>>
        // this, the type of t is going to be Task<Task<int>>
        // Task.Run provides 8 overloads to support combinations of Task vs Task<T>, Cancelable vs non-cancelable, sync vs async delegate
        public async void TestTaskRun()
        {
            int result = await Task.Run(async delegate
            {
                await Task.Delay(1000);
                return 42;
            });
        }

        // await can be used as the language equivalent of Unwrap()
        // double await. We make a Task<Task<int>>, first await gets a Task<int>, second await coerces it to an int
        public async void TestDoubleAwait()
        {
            int result = await await Task.Factory.StartNew(
            async delegate 
            {
                await Task.Delay(1000);
                return 42;
            }, 
            CancellationToken.None,
            TaskCreationOptions.DenyChildAttach,
            TaskScheduler.Default);
        }

        // Notes:
        // How does async work
        // - async keyword does not change code generated by compiler, it is a compiler hint and enables the use of the await keyword
        // what does await do? 
        // - does not peroform a blocking ( e.g. CalculateAsync().Result; )
        // 1. registers continuation with te async operation
        // 2. code that follows me is a continuation, like ContinueWith()
        // 3. gives up the current thread
        // 4. if SycnronozationContext.Current != null, ensures the continuation is posted there (e.g update result on the UI thread)
        // 5. if SycnronozationContext.Current != null, continuation scheduled using current task scheduler
        //     -  4 and 5 behaviors can be customized
        // 6. Coerces the result of the async operation

        // Task Utility combinators: useful for async/ await
        // await Task.Any(t1, t2); creates a task that will complete whan any of the supplied tasks has completed
        // await Task.WhenAll(t1, t2) creates a task that will complete when all of the supplied tasks have completed

    }

}
